# 하이브리드 검색 및 조 취합 로직 문서

## 목차
1. [개요](#개요)
2. [시스템 아키텍처](#시스템-아키텍처)
3. [상세 프로세스](#상세-프로세스)
4. [파라미터 및 설정값](#파라미터-및-설정값)
5. [구체적 예시](#구체적-예시)
6. [로그 해석 가이드](#로그-해석-가이드)
7. [성능 특성](#성능-특성)
8. [코드 참조](#코드-참조)

---

## 개요

### 목적
사용자 계약서의 조항을 표준계약서의 조항과 매칭하여 정합성을 검증하는 하이브리드 검색 시스템

### 핵심 기술
- **Dense Search (FAISS)**: 의미론적 유사도 검색 (85% 가중치)
- **Sparse Search (Whoosh)**: 키워드 기반 검색 (15% 가중치)
- **Multi-Vector Search**: 사용자 조항의 각 하위항목을 독립적으로 검색
- **Article-Level Aggregation**: 청크 단위 결과를 조 단위로 집계

### 시스템 구성
```
표준계약서 인덱스: 82개 청크 (제1조~제11조)
├─ FAISS 벡터 인덱스: 82개 × 3072차원 벡터
└─ Whoosh 키워드 인덱스: 82개 청크 (BM25 스코어링)

사용자 계약서 조항: 1개 조
├─ 하위항목 1: "제공자는 이용자에게 데이터를 제공한다"
├─ 하위항목 2: "데이터 종류: 고객 데이터"
└─ 하위항목 3: "제공 방식: API"
```

---

## 시스템 아키텍처

### 전체 흐름도

```
사용자 조항 입력 (3개 하위항목)
    ↓
┌───┴───┬───────┬───────┐
│       │       │       │
Sub1   Sub2   Sub3    (각 하위항목 독립 검색)
│       │       │
↓       ↓       ↓
[하이브리드 검색] × 3회
│       │       │
↓       ↓       ↓
Top-5  Top-5  Top-5   (각각 5개 청크 선택)
│       │       │
↓       ↓       ↓
제3조   제3조   제5조   (각각 최고 조 1개 선택)
│       │       │
└───┬───┴───────┘
    ↓
[조 단위 재집계]
    ↓
제3조(2개), 제5조(1개)  (하위항목 개수로 정렬)
    ↓
최종 매칭 결과 반환
```

### 데이터 흐름

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 하위항목별 쿼리 생성                                      │
├─────────────────────────────────────────────────────────────┤
│ Input:  하위항목 텍스트 + 조 제목                            │
│ Output: "제공자는...데이터를 제공한다 데이터 제공"            │
└────────────────┬────────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Dense Search (FAISS)                                      │
├─────────────────────────────────────────────────────────────┤
│ • 전체 82개 벡터 검색                                        │
│ • L2 거리 계산 → 유사도 변환                                 │
│ • Top 50개 반환                                              │
│ Output: 50개 청크 (유사도: 0.412 ~ 0.857)                    │
└─────────────────────────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. Sparse Search (Whoosh)                                    │
├─────────────────────────────────────────────────────────────┤
│ • 플레이스홀더 제거 (○○○, □□□)                              │
│ • MeCab 토크나이징                                           │
│ • 전체 82개 문서 검색 (BM25)                                 │
│ • 매칭된 것 중 Top 50개 반환                                 │
│ Output: 48개 청크 (BM25: 10.94 ~ 52.74)                      │
└─────────────────────────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. Score Fusion                                              │
├─────────────────────────────────────────────────────────────┤
│ • Dense 50개 + Sparse 48개 병합                              │
│ • Union: 58개 unique 청크 (42개 중복)                        │
│ • Min-Max 정규화 (각각 독립적으로)                           │
│ • 가중합: 0.85 × Dense + 0.15 × Sparse                       │
│ • 최종 점수로 정렬                                           │
│ Output: 58개 청크 (융합 점수: 0.114 ~ 0.940)                 │
└─────────────────────────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. Top-K 선택 (⚠️ 핵심 필터링)                               │
├─────────────────────────────────────────────────────────────┤
│ • 58개 중 상위 5개만 선택                                    │
│ • 53개 청크 버림                                             │
│ Output: 5개 청크                                             │
└─────────────────────────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 조 단위 그룹핑 및 평균                                    │
├─────────────────────────────────────────────────────────────┤
│ • 5개 청크를 parent_id (조)로 그룹핑                         │
│   예: 제3조(4개), 제5조(1개)                                 │
│ • 각 조별 평균 점수 계산                                     │
│   제3조: (0.940 + 0.923 + 0.865 + 0.841) / 4 = 0.892        │
│   제5조: 0.897 / 1 = 0.897                                   │
│ • 최고 점수 조 선택                                          │
│ Output: 1개 조 (이 하위항목의 매칭 조)                       │
└─────────────────────────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. 하위항목 결과 저장                                        │
├─────────────────────────────────────────────────────────────┤
│ sub_item_results.append({                                    │
│     'sub_item_index': 1,                                     │
│     'matched_article_id': '제3조',                           │
│     'score': 0.892,                                          │
│     'matched_chunks': [4개 청크]                             │
│ })                                                           │
└─────────────────────────────────────────────────────────────┘
                 ↓
          (2, 3번 하위항목 반복)
                 ↓
┌─────────────────────────────────────────────────────────────┐
│ 8. 다중 하위항목 재집계                                      │
├─────────────────────────────────────────────────────────────┤
│ • 3개 하위항목 결과를 조별로 그룹핑                          │
│   제3조: [sub1(0.892), sub2(0.823)]                          │
│   제5조: [sub3(0.801)]                                       │
│                                                              │
│ • 조별 평균 재계산                                           │
│   제3조: (0.892 + 0.823) / 2 = 0.858                         │
│   제5조: 0.801 / 1 = 0.801                                   │
│                                                              │
│ • 정렬 기준                                                  │
│   1순위: 매칭된 하위항목 개수 (내림차순)                     │
│   2순위: 평균 점수 (내림차순)                                │
│   3순위: 조 번호 (오름차순)                                  │
│                                                              │
│ Output: [제3조(2개, 0.858), 제5조(1개, 0.801)]               │
└─────────────────────────────────────────────────────────────┘
                 ↓
          최종 매칭 결과
```

---

## 상세 프로세스

### Phase 1: 하위항목별 검색 (3회 반복)

#### 1.1 쿼리 생성
**코드 위치**: `article_matcher.py:224-242`

```python
# 입력
sub_item = "① 제공자는 이용자에게 데이터를 제공한다."
article_title = "데이터 제공"

# 정규화 (①, 1., (가) 등 제거)
normalized = "제공자는 이용자에게 데이터를 제공한다"

# 최종 쿼리
query = f"{normalized} {article_title}"
# → "제공자는 이용자에게 데이터를 제공한다 데이터 제공"
```

#### 1.2 Dense Search (FAISS)
**코드 위치**: `hybrid_searcher.py:105-149`

**파라미터**:
- `dense_top_k = 50` (기본값)

**프로세스**:
1. **쿼리 임베딩** (Azure OpenAI)
   ```python
   # 모델: text-embedding-3-large
   # 차원: 3072
   # 입력: "제공자는 이용자에게 데이터를 제공한다 데이터 제공"
   # 출력: [0.0234, -0.0891, ..., -0.0456] (3072개 실수)
   ```

2. **FAISS 벡터 검색**
   ```python
   distances, indices = faiss_index.search(query_vector, 50)
   # - 전체 82개 벡터와 L2 거리 계산
   # - 거리 기준 상위 50개 반환
   # - 나머지 32개는 반환되지 않음 (점수도 없음)
   ```

3. **거리 → 유사도 변환**
   ```python
   similarity = 1.0 / (1.0 + L2_distance)

   # 예시:
   # L2=0.0527 → similarity=0.950
   # L2=0.1681 → similarity=0.856
   # L2=2.8571 → similarity=0.259
   ```

**출력**:
```python
[
    {'chunk': {...}, 'score': 0.950, 'source': 'dense'},  # Rank 1
    {'chunk': {...}, 'score': 0.923, 'source': 'dense'},  # Rank 2
    ...
    {'chunk': {...}, 'score': 0.412, 'source': 'dense'}   # Rank 50
]
```

#### 1.3 Sparse Search (Whoosh)
**코드 위치**: `whoosh_searcher.py:43-145`

**파라미터**:
- `sparse_top_k = 50` (기본값)

**프로세스**:
1. **플레이스홀더 제거**
   ```python
   # 입력: "제공자 ○○○는 이용자 □□□에게..."
   # 출력: "제공자 는 이용자 에게..."
   # 제거 대상: ○, □, ●, ■, ◆, ◇, ▲, △, ▼, ▽
   ```

2. **MeCab 토크나이징**
   ```python
   # 입력: "제공자는 이용자에게 데이터를 제공한다"
   # 출력: "제공 자 는 이용 자 에게 데이터 를 제공 한다"
   # 형태소 단위로 분리
   ```

3. **Whoosh BM25 검색**
   ```python
   # QueryParser with OrGroup (OR 연산자)
   # - text_norm 필드 검색
   # - title 필드 검색
   # - 두 필드 결과를 OR로 결합

   # BM25 점수 계산 (매칭된 문서에만)
   # - 전체 82개 문서 검색
   # - 토큰 매칭되지 않은 문서는 점수 없음 (제외)
   # - 매칭된 문서 중 상위 50개 반환
   ```

**BM25 점수 특성**:
- **높은 점수 (40-60)**: 여러 쿼리 토큰 매칭 + 높은 빈도
- **중간 점수 (20-40)**: 일부 토큰 매칭
- **낮은 점수 (10-20)**: 소수 토큰 매칭 또는 낮은 빈도

**출력**:
```python
[
    {'id': 'chunk_023', 'score': 52.74, 'parent_id': '제3조', ...},  # BM25 최고
    {'id': 'chunk_075', 'score': 48.23, 'parent_id': '제5조', ...},
    ...
    {'id': 'chunk_456', 'score': 10.94, 'parent_id': '제25조', ...}  # BM25 최저
]
# 총 48개 (82개 중 48개만 매칭됨)
```

#### 1.4 Score Fusion
**코드 위치**: `hybrid_searcher.py:238-322`

**1단계: Min-Max 정규화**

Dense와 Sparse를 **각각 독립적으로** 정규화:

```python
# Dense 정규화 (50개)
min_dense = 0.412
max_dense = 0.950
range = 0.538

chunk_1: (0.950 - 0.412) / 0.538 = 1.000
chunk_2: (0.923 - 0.412) / 0.538 = 0.949
...
chunk_50: (0.412 - 0.412) / 0.538 = 0.000

# Sparse 정규화 (48개)
min_sparse = 10.94
max_sparse = 52.74
range = 41.80

chunk_1: (52.74 - 10.94) / 41.80 = 1.000
chunk_2: (48.23 - 10.94) / 41.80 = 0.892
...
chunk_48: (10.94 - 10.94) / 41.80 = 0.000
```

**2단계: Union 생성**

```python
# Dense: 50개 청크 (ID: 1, 2, 3, ..., 50)
# Sparse: 48개 청크 (ID: 1, 5, 7, ..., 100)
#
# Union 계산:
# - Dense만: 8개 (ID: 2, 4, 6, ...)
# - Sparse만: 6개 (ID: 55, 78, ...)
# - 양쪽 모두: 42개 (ID: 1, 3, 5, ...)
#
# Total unique: 50 + 48 - 42 = 58개
```

**3단계: 가중 융합**

```python
for each chunk in 58:
    final_score = 0.85 × dense_normalized + 0.15 × sparse_normalized

    # 예시:
    # Chunk A (양쪽 모두 존재)
    # dense_norm=1.000, sparse_norm=0.892
    # → 0.85×1.000 + 0.15×0.892 = 0.850 + 0.134 = 0.984

    # Chunk B (Dense만)
    # dense_norm=0.801, sparse_norm=0.000
    # → 0.85×0.801 + 0.15×0.000 = 0.681

    # Chunk C (Sparse만)
    # dense_norm=0.000, sparse_norm=0.654
    # → 0.85×0.000 + 0.15×0.654 = 0.098
```

**4단계: 정렬**

```python
# 융합 점수 기준 내림차순 정렬
fused_results.sort(key=lambda x: x['score'], reverse=True)

# 결과: 58개 청크, 점수 0.984 ~ 0.098
```

**출력**:
```python
[
    {'chunk': {...}, 'score': 0.984, 'dense_score': 1.000, 'sparse_score': 0.892, 'parent_id': '제3조'},
    {'chunk': {...}, 'score': 0.940, 'dense_score': 0.961, 'sparse_score': 0.818, 'parent_id': '제3조'},
    ...
    {'chunk': {...}, 'score': 0.098, 'dense_score': 0.000, 'sparse_score': 0.654, 'parent_id': '제10조'}
]
# 총 58개
```

#### 1.5 Top-K 선택 (핵심 필터링)
**코드 위치**: `hybrid_searcher.py:365`

```python
# ⚠️ 가장 중요한 필터링 단계
final_results = fused_results[:top_k]
# top_k = 5 (article_matcher에서 전달)

# 58개 중 상위 5개만 선택
# 나머지 53개는 버려짐!
```

**출력**:
```python
[
    {'chunk': {...}, 'score': 0.984, 'parent_id': '제3조'},  # Rank 1
    {'chunk': {...}, 'score': 0.940, 'parent_id': '제3조'},  # Rank 2
    {'chunk': {...}, 'score': 0.897, 'parent_id': '제5조'},  # Rank 3
    {'chunk': {...}, 'score': 0.865, 'parent_id': '제3조'},  # Rank 4
    {'chunk': {...}, 'score': 0.841, 'parent_id': '제3조'}   # Rank 5
]
# 총 5개만 반환
```

#### 1.6 조 단위 그룹핑 및 평균
**코드 위치**: `article_matcher.py:306-359`

**입력**: 5개 청크

**1단계: parent_id로 그룹핑**

```python
article_groups = {
    '제3조': [
        {'score': 0.984, ...},
        {'score': 0.940, ...},
        {'score': 0.865, ...},
        {'score': 0.841, ...}
    ],  # 4개 청크
    '제5조': [
        {'score': 0.897, ...}
    ]   # 1개 청크
}
```

**2단계: 조별 평균 점수 계산**

```python
제3조: (0.984 + 0.940 + 0.865 + 0.841) / 4 = 3.630 / 4 = 0.908
제5조: 0.897 / 1 = 0.897
```

**3단계: 최고 점수 조 선택**

```python
best_article = max(article_scores, key=lambda x: x['score'])
# → 제3조 (0.908 > 0.897)
```

**출력**:
```python
{
    'parent_id': '제3조',
    'title': '데이터 제공 범위',
    'score': 0.908,
    'chunks': [4개 청크]
}
```

#### 1.7 하위항목 결과 저장
**코드 위치**: `article_matcher.py:178-186`

```python
sub_item_results.append({
    'sub_item_index': 1,
    'matched_article_id': '제3조',
    'score': 0.908,
    'matched_chunks': [4개 청크]
})
```

### Phase 2, 3: 나머지 하위항목 처리

동일한 과정을 하위항목 2, 3에 대해 반복:

```python
# 하위항목 2 처리 후
sub_item_results.append({
    'sub_item_index': 2,
    'matched_article_id': '제3조',
    'score': 0.823,
    'matched_chunks': [3개 청크]
})

# 하위항목 3 처리 후
sub_item_results.append({
    'sub_item_index': 3,
    'matched_article_id': '제5조',
    'score': 0.801,
    'matched_chunks': [4개 청크]
})
```

### Phase 4: 다중 하위항목 재집계

**코드 위치**: `article_matcher.py:361-439`

**입력**: 3개 하위항목 결과

```python
sub_item_results = [
    {'sub_item_index': 1, 'matched_article_id': '제3조', 'score': 0.908, ...},
    {'sub_item_index': 2, 'matched_article_id': '제3조', 'score': 0.823, ...},
    {'sub_item_index': 3, 'matched_article_id': '제5조', 'score': 0.801, ...}
]
```

**1단계: 조별 그룹핑**

```python
article_groups = {
    '제3조': [
        {'sub_item_index': 1, 'score': 0.908, ...},
        {'sub_item_index': 2, 'score': 0.823, ...}
    ],  # 2개 하위항목
    '제5조': [
        {'sub_item_index': 3, 'score': 0.801, ...}
    ]   # 1개 하위항목
}
```

**2단계: 조별 평균 재계산**

```python
제3조:
  - 하위항목: [1, 2]
  - 점수: [0.908, 0.823]
  - 평균: (0.908 + 0.823) / 2 = 0.866
  - 매칭 하위항목 수: 2개

제5조:
  - 하위항목: [3]
  - 점수: [0.801]
  - 평균: 0.801 / 1 = 0.801
  - 매칭 하위항목 수: 1개
```

**3단계: 정렬**

```python
# 정렬 기준 (우선순위 순):
# 1. 매칭 하위항목 수 (내림차순)
# 2. 평균 점수 (내림차순)
# 3. 조 번호 (오름차순)

article_scores.sort(key=lambda x: (
    -x['num_sub_items'],  # -2 vs -1 → 제3조 우선
    -x['score'],          # -0.866 vs -0.801
    extract_number(x['parent_id'])  # 3 vs 5
))

# 결과: [제3조, 제5조] 순서
```

**출력**:

```python
[
    {
        'parent_id': '제3조',
        'title': '데이터 제공 범위',
        'score': 0.866,
        'num_sub_items': 2,
        'matched_sub_items': [1, 2],
        'matched_chunks': [7개 unique 청크]
    },
    {
        'parent_id': '제5조',
        'title': '데이터 제공 방법',
        'score': 0.801,
        'num_sub_items': 1,
        'matched_sub_items': [3],
        'matched_chunks': [4개 청크]
    }
]
```

**⚠️ 중요**: 모든 매칭된 조를 반환 (Top-1만 아님)

---

## 파라미터 및 설정값

### 검색 파라미터

| 파라미터 | 값 | 설정 위치 | 의미 |
|---------|---|----------|------|
| `top_k` | **5** | `article_matcher.py:61` | 각 하위항목당 선택할 최종 청크 수 |
| `dense_top_k` | **50** | `hybrid_searcher.py:329` | FAISS에서 반환할 청크 수 |
| `sparse_top_k` | **50** | `hybrid_searcher.py:329` | Whoosh에서 반환할 청크 수 |

### 가중치

| 항목 | 값 | 설정 위치 | 의미 |
|-----|---|----------|------|
| Dense 가중치 | **0.85** | `hybrid_searcher.py:38` | FAISS 유사도 가중치 (85%) |
| Sparse 가중치 | **0.15** | `hybrid_searcher.py:39` | Whoosh BM25 가중치 (15%) |

### 정렬 우선순위

1. **매칭 하위항목 수** (내림차순) - 가장 중요
2. **평균 점수** (내림차순)
3. **조 번호** (오름차순) - 동점 시

**예시**:
- 제3조 (2개 하위항목, 0.85) > 제5조 (1개 하위항목, 0.90)
- 제3조 (2개 하위항목, 0.85) > 제3조 (2개 하위항목, 0.80)
- 제3조 (1개 하위항목, 0.85) > 제10조 (1개 하위항목, 0.85)

---

## 구체적 예시

### 시나리오: 3개 하위항목 검색

**사용자 조항**:
```
제5조 (데이터 제공)
① 제공자는 이용자에게 데이터를 제공한다.
② 데이터 종류: 고객 거래 데이터
③ 제공 방식: API를 통한 실시간 제공
```

### 하위항목 1 검색 결과

**쿼리**: "제공자는 이용자에게 데이터를 제공한다 데이터 제공"

**Dense (FAISS)**:
- 검색: 82개 벡터
- 반환: 50개
- 점수 범위: 0.412 ~ 0.950

**Sparse (Whoosh)**:
- 검색: 82개 문서
- 매칭: 48개
- 반환: 48개
- 점수 범위: 10.94 ~ 52.74

**Fusion**:
- Union: 58개 unique 청크
- 중복: 42개
- 중복률: 72.4%

**Top-5**:
```
Rank 1: 제3조 chunk (0.984)
Rank 2: 제3조 chunk (0.940)
Rank 3: 제5조 chunk (0.897)
Rank 4: 제3조 chunk (0.865)
Rank 5: 제3조 chunk (0.841)
```

**조별 평균**:
- 제3조: (0.984 + 0.940 + 0.865 + 0.841) / 4 = **0.908**
- 제5조: 0.897 / 1 = **0.897**

**선택**: 제3조 (0.908 > 0.897)

### 하위항목 2 검색 결과

**쿼리**: "데이터 종류 고객 거래 데이터 데이터 제공"

**최종 선택**: 제3조 (score: 0.823)

### 하위항목 3 검색 결과

**쿼리**: "제공 방식 API를 통한 실시간 제공 데이터 제공"

**최종 선택**: 제5조 (score: 0.801)

### 최종 집계

**하위항목별 결과**:
```
하위항목 1 → 제3조 (0.908)
하위항목 2 → 제3조 (0.823)
하위항목 3 → 제5조 (0.801)
```

**조별 재집계**:
```
제3조: (0.908 + 0.823) / 2 = 0.866 (2개 하위항목)
제5조: 0.801 / 1 = 0.801 (1개 하위항목)
```

**정렬**:
```
1위: 제3조 (2개 하위항목, 0.866) ← 승자
2위: 제5조 (1개 하위항목, 0.801)
```

**최종 반환**:
```json
{
  "matched": true,
  "matched_articles": [
    {
      "parent_id": "제3조",
      "title": "데이터 제공 범위",
      "score": 0.866,
      "num_sub_items": 2,
      "matched_sub_items": [1, 2]
    },
    {
      "parent_id": "제5조",
      "title": "데이터 제공 방법",
      "score": 0.801,
      "num_sub_items": 1,
      "matched_sub_items": [3]
    }
  ]
}
```

---

## 로그 해석 가이드

### 일반적인 로그 패턴

```
[INFO] Whoosh 검색 성공: 82개, 점수 범위 [10.9386 ~ 52.7390]
[INFO] ✓ Sparse 검색 완료: 50개, 점수 범위 [10.9386 ~ 52.7390]
[INFO]   Sparse-Dense 중복: 42/58 (72.4%)
[INFO]   가중치 - Dense: 0.85, Sparse: 0.15
[INFO]   매칭 완료: 2개 조
[INFO]     1. 제3조: 0.866 (D:0.887, S:0.645, 하위항목:2)
[INFO]     2. 제5조: 0.801 (D:0.823, S:0.512, 하위항목:1)
```

### 각 로그의 의미

#### `Whoosh 검색 성공: 82개`
- **82개**: Whoosh가 찾은 전체 매칭 문서 수
- 실제 쿼리 토큰과 매칭된 모든 문서
- `limit` 적용 전 숫자일 수 있음

#### `Sparse 검색 완료: 50개`
- **50개**: `sparse_top_k` 제한 적용 후 반환된 결과 수
- BM25 점수 기준 상위 50개

#### `점수 범위 [10.9386 ~ 52.7390]`
- **10.9386**: 50개 중 최저 BM25 점수
- **52.7390**: 50개 중 최고 BM25 점수
- 원본 점수 (정규화 전)

#### `Sparse-Dense 중복: 42/58 (72.4%)`
- **42**: Dense와 Sparse 양쪽에 모두 나타난 청크 수
- **58**: Dense(50) + Sparse(50) - 중복(42) = 총 unique 청크 수
- **72.4%**: 42 ÷ 58 × 100 = 중복률
- 높은 중복률 (>70%) = 의미론적/키워드 검색 일치도 높음

#### `가중치 - Dense: 0.85, Sparse: 0.15`
- 적용된 가중치 (기본값 또는 Adaptive Weighting 후)
- Sparse 실패 시: Dense: 1.0, Sparse: 0.0

#### `제3조: 0.866 (D:0.887, S:0.645, 하위항목:2)`
- **0.866**: 최종 조 평균 점수
- **D:0.887**: 이 조의 청크들의 평균 Dense 정규화 점수
- **S:0.645**: 이 조의 청크들의 평균 Sparse 정규화 점수
- **하위항목:2**: 2개 하위항목이 이 조를 선택함

### 문제 진단 로그

#### Sparse 검색 실패
```
[WARNING] Whoosh 검색 결과 0개 - 쿼리: ...
[WARNING] Sparse 검색 결과 없음 (쿼리 길이: 45)
[WARNING] Sparse 검색 결과 없음 - Adaptive Weighting 적용 (Dense: 1.0)
```
- **원인**: 키워드 매칭 실패 (모든 플레이스홀더거나 토큰화 실패)
- **조치**: Adaptive Weighting으로 Dense만 사용 (가중치 1.0)

#### 중복률 낮음
```
[INFO] Sparse-Dense 중복: 8/52 (15.4%)
```
- **원인**: Dense와 Sparse가 완전히 다른 청크 반환
- **해석**: 의미론적/키워드 검색 불일치
- **조치**: 쿼리 품질 검토 필요

---

## 성능 특성

### 처리 시간 분석

| 단계 | 예상 시간 | 병목 요소 |
|-----|----------|----------|
| 쿼리 생성 | <1ms | - |
| Dense Search (FAISS) | 5-10ms | 인덱스 크기 |
| Sparse Search (Whoosh) | 20-50ms | MeCab 토크나이징 |
| Score Fusion | 2-5ms | - |
| 조 단위 집계 | <1ms | - |
| **하위항목당 총합** | **30-70ms** | - |
| **3개 하위항목** | **90-210ms** | - |

### 병목 지점

1. **MeCab 토크나이징** (20-30ms)
   - CPU 바운드
   - 긴 쿼리에서 더 느림

2. **Azure OpenAI 임베딩** (100-300ms)
   - 네트워크 지연
   - 가장 큰 병목

3. **Top-K 필터링**
   - 58개 중 5개만 선택
   - 53개 청크 정보 손실

### 최적화 기회

1. **임베딩 캐싱**
   - 동일 쿼리 재사용 시 캐시 적용
   - 300ms → <1ms

2. **Top-K 증가**
   - 현재: 5개 → 제안: 10-20개
   - 더 많은 조가 평균 계산에 참여
   - 정확도 향상 가능

3. **병렬 처리**
   - 3개 하위항목 순차 처리
   - 병렬화 시: 210ms → 70ms (3배 향상)

---

## 코드 참조

### 주요 파일 및 메서드

| 파일 | 메서드 | 라인 | 기능 |
|-----|--------|-----|------|
| `article_matcher.py` | `find_matching_article()` | 56-124 | 전체 매칭 프로세스 오케스트레이션 |
| `article_matcher.py` | `_search_with_sub_items()` | 126-196 | 하위항목별 검색 반복 |
| `article_matcher.py` | `_build_search_query()` | 224-242 | 쿼리 생성 (하위항목 + 제목) |
| `article_matcher.py` | `_select_best_article_from_chunks()` | 306-359 | Top-5 청크 → 최고 조 선택 |
| `article_matcher.py` | `_aggregate_sub_item_results()` | 361-439 | 다중 하위항목 재집계 |
| `hybrid_searcher.py` | `search()` | 323-405 | 하이브리드 검색 오케스트레이션 |
| `hybrid_searcher.py` | `dense_search()` | 105-149 | FAISS 벡터 검색 |
| `hybrid_searcher.py` | `sparse_search()` | 151-207 | Whoosh 키워드 검색 |
| `hybrid_searcher.py` | `normalize_scores()` | 209-236 | Min-Max 정규화 |
| `hybrid_searcher.py` | `fuse_scores()` | 238-322 | 점수 융합 (0.85×D + 0.15×S) |
| `whoosh_searcher.py` | `search()` | 43-145 | Whoosh BM25 검색 |
| `whoosh_searcher.py` | `_remove_placeholders()` | 147-175 | 플레이스홀더 제거 |

### 핵심 코드 스니펫

#### 하위항목별 검색 루프
```python
# article_matcher.py:156-191
for idx, sub_item in enumerate(content_items, 1):
    # 정규화
    normalized = self._normalize_sub_item(sub_item)

    # 쿼리 생성
    query = self._build_search_query(normalized, article_title)

    # 하이브리드 검색 (top_k=5)
    chunk_results = self._hybrid_search(query, contract_type, top_k, contract_id)

    # 조 선택 (5개 청크 → 1개 조)
    best_article = self._select_best_article_from_chunks(chunk_results)

    # 결과 저장
    sub_item_results.append({
        'sub_item_index': idx,
        'matched_article_id': best_article['parent_id'],
        'score': best_article['score'],
        'matched_chunks': best_article['chunks']
    })
```

#### 점수 융합
```python
# hybrid_searcher.py:303-308
for chunk_id, data in chunk_scores.items():
    final_score = (
        effective_dense_weight * data['dense_score'] +
        effective_sparse_weight * data['sparse_score']
    )
    # 0.85 × dense + 0.15 × sparse
```

#### 조별 재집계
```python
# article_matcher.py:389-394
for article_id, results in article_groups.items():
    # 하위항목별 점수 평균
    avg_score = sum(r['score'] for r in results) / len(results)

    article_scores.append({
        'score': avg_score,
        'num_sub_items': len(results)  # 매칭 하위항목 수
    })
```

---

## 부록

### 용어 정의

- **청크 (Chunk)**: 표준계약서의 최소 검색 단위 (보통 1개 하위항목)
- **조 (Article)**: 표준계약서의 조항 (예: 제3조)
- **하위항목 (Sub-item)**: 사용자 조항 내의 개별 항목 (①, ②, ③)
- **Dense Search**: 벡터 임베딩 기반 의미론적 검색 (FAISS)
- **Sparse Search**: 키워드 기반 검색 (Whoosh BM25)
- **Fusion**: Dense와 Sparse 결과를 가중 평균으로 결합
- **Top-K**: 상위 K개 결과 선택 (여기서는 5개)

### 자주 묻는 질문 (FAQ)

**Q1: 왜 Top-K가 5개인가요?**
- 너무 적으면 (1-3개): 조 평균 계산에 부족
- 너무 많으면 (20-50개): 노이즈 청크 포함, 평균 희석
- 5개: 경험적 최적값 (조당 평균 3-7개 청크)

**Q2: Dense 85%, Sparse 15% 비율의 근거는?**
- Dense: 의미론적 유사도가 더 중요 (paraphrasing 대응)
- Sparse: 핵심 키워드 확인용 보조 (exact match)
- 비율 조정 가능 (`hybrid_searcher.py:38-39`)

**Q3: 왜 하위항목마다 별도로 검색하나요?**
- 각 하위항목이 서로 다른 주제 다룰 수 있음
- 하위항목 1: 데이터 제공 의무
- 하위항목 2: 데이터 종류
- 하위항목 3: 제공 방식
- 별도 검색으로 각각 최적 매칭 가능

**Q4: 왜 최종 결과가 여러 조를 반환하나요?**
- 사용자 조항이 여러 표준 조항과 관련될 수 있음
- 우선순위 정렬로 가장 관련성 높은 조 확인
- LLM 비교 단계에서 모든 후보 검토 가능

### 관련 문서

- `WHOOSH_FIX_README.md`: Whoosh 인덱스 문제 해결
- `REBUILD_WHOOSH_INDEX.md`: 인덱스 재생성 가이드
- API 문서: FastAPI `/api/validation/` 엔드포인트

---

**문서 버전**: 1.0
**최종 수정일**: 2025-10-29
**작성자**: Claude Code Analysis
